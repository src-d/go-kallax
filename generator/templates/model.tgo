{{range .Models}}

// New{{.Name}} returns a new instance of {{.Name}}.
func New{{.Name}}({{.CtorArgs}}) {{.CtorReturns}} {
        {{.CtorRetVars}} = {{if .CtorFunc}}{{.CtorFunc.Name}}({{.CtorArgVars}}){{else}}&{{.Name}}{}{{end}}
        if record != nil {
                record.SetID(kallax.NewID())
        }
        return
}


func (r *{{.Name}}) ColumnAddress(col string) (interface{}, error) {
        switch col {
                {{$.GenColumnAddresses .}}
        default:
                return nil, fmt.Errorf("invalid column in {{.Name}}: %s", col)
        }
}

func (r *{{.Name}}) Value(col string) (interface{}, error) {
        switch col {
                {{$.GenColumnValues .}}
        default:
                return nil, fmt.Errorf("invalid column in {{.Name}}: %s", col)
        }
}

// {{.StoreName}} is the entity to access the records of the type {{.Name}}
// in the database.
type {{.StoreName}} struct {
	*kallax.Store
}

// New{{.StoreName}} creates a new instance of {{.StoreName}}
// using a SQL database.
func New{{.StoreName}}(db *sql.DB) *{{.StoreName}} {
	return &{{.StoreName}}{kallax.NewStore(db, Schema.{{.Name}}.BaseSchema)}
}

// Insert inserts a {{.Name}} in the database. A non-persisted object is
// required for this operation.
func (s *{{.StoreName}}) Insert(record *{{.Name}}) error {
        {{if .Events.Has "BeforeSave"}}
        if err := record.BeforeSave(); err != nil {
                return err
        }
        {{end}}
        {{if .Events.Has "BeforeInsert"}}
        if err := record.BeforeInsert(); err != nil {
        }
        {{end}}
        {{if or (.Events.Has "AfterSave") (.Events.Has "AfterInsert")}}
        return s.Store.Transaction(func(store *kallax.Store) error {
                if err := store.Insert(record); err != nil {
                        return err
                }

                return record.{{if .Events.Has "AfterSave"}}AfterSave{{else}}AfterInsert{{end}}()
        })
        {{else}}
        return s.Store.Update(record, cols...)
        {{end}}
}

// Update updates the given record on the database. If the columns are given,
// only these columns will be updated. Otherwise all of them will be.
// Be very careful with this, as you will have a potentially different object
// in memory but not on the database.
// Only writable records can be updated. Writable objects are those that have
// been just inserted or retrieved using a query with no custom select fields.
func (s *{{.StoreName}}) Update(record *{{.Name}}, cols ...kallax.SchemaField) (updated int64, err error) {
        {{if .Events.Has "BeforeSave"}}
        if err := record.BeforeSave(); err != nil {
                return 0, err
        }
        {{end}}
        {{if .Events.Has "BeforeUpdate"}}
        if err := record.BeforeUpdate(); err != nil {
                return 0, err
        }
        {{end}}
        {{if or (.Events.Has "AfterSave") (.Events.Has "AfterUpdate")}}
        err = s.Store.Transaction(func(store *kallax.Store) error {
                updated, err = store.Update(record, cols...)
                if err != nil {
                        return err
                }

                return record.{{if .Events.Has "AfterSave"}}AfterSave{{else}}AfterUpdate{{end}}()
        })
        if err != nil {
                return 0, err
        }
        {{else}}
        updated, err = s.Store.Update(record, cols...)
        {{end}}
        return
}

// Save inserts the object if the record is not persisted, otherwise it updates
// it. Same rules of Update and Insert apply depending on the case.
func (s *{{.StoreName}}) Save(record *{{.Name}}) (updated bool,  err error) {
        {{if .Events.Has "BeforeSave"}}
        if err := record.BeforeSave(); err != nil {
                return false, err
        }
        {{end}}
        {{if .Events.Has "BeforeInsert"}}
        if !record.IsPersisted() {
                if err := record.BeforeInsert(); err != nil {
                        return false, err
                }
        }
        {{end}}
        {{if .Events.Has "BeforeUpdate"}}
        if record.IsPersisted() {
                if err := record.BeforeUpdate(); err != nil {
                        return false, err
                }
        }
        {{end}}
        {{if and (.Events.Has "AfterUpdate") (.Events.Has "AfterInsert")}}
        if !record.IsPersisted() {
                {{template "afterSaveEvent" "AfterInsert"}}
        } else {
                {{template "afterSaveEvent" "AfterUpdate"}}
        }
        {{else if .Events.Has "AfterSave"}}
        {{template "afterSaveEvent" "AfterSave"}}
        {{else if .Events.Has "AfterInsert"}}
        if !record.IsPersisted() {
                {{template "afterSaveEvent" "AfterInsert"}}
        } else {
                updated, err = s.Store.Save(record)
        }
        {{else if .Events.Has "AfterUpdate"}}
        if record.IsPersisted() {
                {{template "afterSaveEvent" "AfterUpdate"}}
        } else {
                updated, err = s.Store.Save(record)
        }
        {{else}}
        updated, err = s.Store.Save(record)
        {{end}}
        return
}

// Delete removes the given record from the database.
func (s *{{.StoreName}}) Delete(record *{{.Name}}) error {
	return s.Store.Delete(record)
}

// Find returns the set of results for the given query.
func (s *{{.StoreName}}) Find(q *{{.QueryName}}) (*{{.ResultSetName}}, error) {
	rs, err := s.Store.Find(q)
	if err != nil {
		return nil, err
	}

	return New{{.ResultSetName}}(rs), nil
}

// MustFind returns the set of results for the given query, but panics yf there
// is any error.
func (s *{{.StoreName}}) MustFind(q *{{.QueryName}}) *{{.ResultSetName}} {
	return New{{.ResultSetName}}(s.Store.MustFind(q))
}

// Count returns the number of rows that would be retrieved with the given
// query.
func (s *{{.StoreName}}) Count(q *{{.QueryName}}) (int64, error) {
	return s.Store.Count(q)
}

// MustCount returns the number of rows that would be retrieved with the given
// query, but panics if there is an error.
func (s *{{.StoreName}}) MustCount(q *{{.QueryName}}) int64 {
	return s.Store.MustCount(q)
}

// FindOne returns the first row returned by the given query.
// `sql.ErrNoRows` is returned if there are no results.
func (s *{{.StoreName}}) FindOne(q *{{.QueryName}}) (*{{.Name}}, error) {
	q.Limit(1)
        rs, err := s.Find(q)
        if err != nil {
                return nil, err
        }

        if !rs.Next() {
                return nil, sql.ErrNoRows
        }

        record, err := rs.Get()
        if err != nil {
                return nil, err
        }

        if err := rs.Close(); err != nil {
                return nil, err
        }

        return record, nil
}

// MustFindOne returns the first row retrieved by the given query. It panics
// if there is an error or if there are no rows.
func (s *{{.StoreName}}) MustFindOne(q *{{.QueryName}}) *{{.Name}} {
        record, err := s.FindOne(q)
        if err != nil {
                panic(err)
        }
        return record
}

// Reload refreshes the {{.Name}} with the data in the database and
// makes it writable.
func (s *{{.StoreName}}) Reload(record *{{.Name}}) error {
        return s.Store.Reload(record)
}

// Transaction executes the given callback in a transaction and rollbacks if
// an error is returned.
// The transaction is only open in the store passed as a parameter to the
// callback.
func (s *{{.StoreName}}) Transaction(callback func(*{{.StoreName}}) error) error {
        if callback == nil {
                return kallax.ErrInvalidTxCallback
        }

        return s.Store.Transaction(func(store *kallax.Store) error {
                return callback(&{{.StoreName}}{store})
        })
}

{{template "query" .}}

{{template "resultset" .}}

{{end}}
