{{range .Models}}

// New{{.Name}} returns a new instance of {{.Name}}.
func New{{.Name}}({{.CtorArgs}}) {{.CtorReturns}} {
        {{.CtorRetVars}} = {{if .CtorFunc}}{{.CtorFunc.Name}}({{.CtorArgVars}}){{else}}&{{.Name}}{}{{end}}
        if record != nil {
                record.SetID(kallax.NewID())
        }
        return
}


func (r *{{.Name}}) ColumnAddress(col string) (interface{}, error) {
        switch col {
                {{$.GenColumnAddresses .}}
        default:
                return nil, fmt.Errorf("invalid column in {{.Name}}: %s", col)
        }
}

func (r *{{.Name}}) Value(col string) (interface{}, error) {
        switch col {
                {{$.GenColumnValues .}}
        default:
                return nil, fmt.Errorf("invalid column in {{.Name}}: %s", col)
        }
}

// {{.StoreName}} is the entity to access the records of the type {{.Name}}
// in the database.
type {{.StoreName}} struct {
	*kallax.Store
}

// New{{.StoreName}} creates a new instance of {{.StoreName}}
// using a SQL database.
func New{{.StoreName}}(db *sql.DB) *{{.StoreName}} {
	return &{{.StoreName}}{kallax.NewStore(db, Schema.{{.Name}}.BaseSchema)}
}

// Insert inserts a {{.Name}} in the database. A non-persisted object is
// required for this operation.
func (s *{{.StoreName}}) Insert(record *{{.Name}}) error {
	return s.Store.Insert(record)
}

// Update updates the given record on the database. If the columns are given,
// only these columns will be updated. Otherwise all of them will be.
// Be very careful with this, as you will have a potentially different object
// in memory but not on the database.
// Only writable records can be updated. Writable objects are those that have
// been just inserted or retrieved using a query with no custom select fields.
func (s *{{.StoreName}}) Update(record *{{.Name}}, cols ...kallax.SchemaField) (int64, error) {
	return s.Store.Update(record, cols...)
}

// Save inserts the object if the record is not persisted, otherwise it updates
// it. Same rules of Update and Insert apply depending on the case.
func (s *{{.StoreName}}) Save(record *{{.Name}}) (updated bool,  err error) {
	return s.Store.Save(record)
}

// Delete removes the given record from the database.
func (s *{{.StoreName}}) Delete(record *{{.Name}}) error {
	return s.Store.Delete(record)
}

// Find returns the set of results for the given query.
func (s *{{.StoreName}}) Find(q *{{.QueryName}}) (*{{.ResultSetName}}, error) {
	rs, err := s.Store.Find(q)
	if err != nil {
		return nil, err
	}

	return New{{.ResultSetName}}(rs), nil
}

// MustFind returns the set of results for the given query, but panics yf there
// is any error.
func (s *{{.StoreName}}) MustFind(q *{{.QueryName}}) *{{.ResultSetName}} {
	return New{{.ResultSetName}}(s.Store.MustFind(q))
}

// Count returns the number of rows that would be retrieved with the given
// query.
func (s *{{.StoreName}}) Count(q *{{.QueryName}}) (int64, error) {
	return s.Store.Count(q)
}

// MustCount returns the number of rows that would be retrieved with the given
// query, but panics if there is an error.
func (s *{{.StoreName}}) MustCount(q *{{.QueryName}}) int64 {
	return s.Store.MustCount(q)
}

// FindOne returns the first row returned by the given query.
// `sql.ErrNoRows` is returned if there are no results.
func (s *{{.StoreName}}) FindOne(q *{{.QueryName}}) (*{{.Name}}, error) {
	q.Limit(1)
        rs, err := s.Find(q)
        if err != nil {
                return nil, err
        }

        if !rs.Next() {
                return nil, sql.ErrNoRows
        }

        record, err := rs.Get()
        if err != nil {
                return nil, err
        }

        if err := rs.Close(); err != nil {
                return nil, err
        }

        return record, nil
}

// MustFindOne returns the first row retrieved by the given query. It panics
// if there is an error or if there are no rows.
func (s *{{.StoreName}}) MustFindOne(q *{{.QueryName}}) *{{.Name}} {
        record, err := s.FindOne(q)
        if err != nil {
                panic(err)
        }
        return record
}

// Reload refreshes the {{.Name}} with the data in the database and
// makes it writable.
func (s *{{.StoreName}}) Reload(record *{{.Name}}) error {
        return s.Store.Reload(record)
}

{{template "query" .}}

{{template "resultset" .}}

{{end}}
